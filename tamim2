// lamda
function<return_type(types)> function_name = [&]( parameters ) -> return_type {
    
};

// bs
auto check = [&](int x) -> bool {
    return /* condition using mid */;
};

int low = 0, high = n - 1, ans = -1;
while (low <= high) {
    int mid = low + (high - low) / 2;
    if (check(mid)) {
        ans = mid;
        low = mid + 1;
    } else {
        high = mid - 1; // lower bound
    }
}

//num theory
// const int MAXN = 2e6 + 10;

// vector<bool> is_Prime(MAXN, true);
// vector<int> divs[MAXN];
// int spf[MAXN]; // Smallest Prime Factor

// void sieve()
// {
//     is_Prime[0] = is_Prime[1] = false;

//     for (int i = 2; i < MAXN; ++i)
//     {
//         if (is_Prime[i])
//         {
//             for (int j = i * i; j < MAXN; j += i)
//             {
//                 is_Prime[j] = false;
//                 if (spf[j] == 0)
//                     spf[j] = i;
//             }
//         }
//     }
// }

// void divisors()
// {
//     for (int i = 1; i < MAXN; ++i)
//         for (int j = i; j < MAXN; j += i)
//             divs[j].push_back(i);
// }

// vector<int> prime_factors(int n)
// {
//     vll ans;
//     while (n > 1)
//     {
//         int _lp = spf[n];
//         if (is_Prime[n])
//         {
//             ans.pb(n);
//             break;
//         }
//         while (n % _lp == 0)
//         {
//             n /= _lp;
//             ans.pb(_lp);
//         }
//     }

//     return ans;
// }

// dfstree
int n;
cin >> n;

vector<vector<int>> adj(n + 10);
for (int i = 0; i < n - 1; ++i) {
    int u, v;
    cin >> u >> v;
    adj[u].push_back(v);
    adj[v].push_back(u);
}

// vector<int> lvl(n + 10);        
// vector<int> h(n + 10);          
// vector<int> stree(n + 10, 1);   

function<void(int, int)> dfs = [&](int u, int p) -> void {
    // lvl[u] = lvl[p] + 1; // If root is 0-indexed, set lvl[0] = -1

    for (int v : adj[u]) {
        if (v == p) continue;

        // lvl[v] = lvl[u] + 1;
        dfs(v, u);
        // h[u] = max(h[u], h[v] + 1);
        // stree[u] += stree[v];
    }
};

dfs(1, 0); // root = 1

// dfsgraph
int n, m;
cin >> n >> m;

vector<vector<int>> adj(n + 1);
vector<int> vis(n + 1, 0);

for (int i = 0; i < m; ++i) {
    int u, v;
    cin >> u >> v;
    adj[u].push_back(v);
    adj[v].push_back(u);
}

function<void(int)> dfs = [&](int u) {
    vis[u] = 1;
    for (int v : adj[u]) {
        if (!vis[v])
            dfs(v);
    }
};

for (int i = 1; i <= n; ++i) {
    if (!vis[i]) {
        dfs(i);
    }
}

// dsu


/*
Initialize DSU
DSU dsu(n);  // for n elements (1-indexed)


int root = dsu.find(x);  // returns the representative (root) of x

Check if Two Elements Are in the Same Component
if (dsu.same(x, y)) {
    // x and y are connected
}

Merge Two Components
dsu.merge(x, y);  // merges components of x and y, if different

Get Size of a Component
int size = dsu.get_size(x);  // returns size of component containing x
Count Connected Components


int components = dsu.count();  // number of disjoint sets
*/
struct DSU
{
    vector<int> par, rnk, sz;
    int c;
    DSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n)
    {
        for (int i = 1; i <= n; ++i)
            par[i] = i;
    }
    int find(int i)
    {
        return (par[i] == i ? i : (par[i] = find(par[i])));
    }
    bool same(int i, int j)
    {
        return find(i) == find(j);
    }
    int get_size(int i)
    {
        return sz[find(i)];
    }
    int count()
    {
        return c; // connected components
    }
    int merge(int i, int j)
    {
        if ((i = find(i)) == (j = find(j)))
            return -1;
        else
            --c;
        if (rnk[i] > rnk[j])
            swap(i, j);
        par[i] = j;
        sz[j] += sz[i];
        if (rnk[i] == rnk[j])
            rnk[j]++;
        return j;
    }
};

// Fenwick

struct Fenwick {
    int n;
    vector<long long> bit;

    Fenwick(int n) {
        this->n = n;
        bit.assign(n + 1, 0);
    }

    void add(int idx, long long val) {
        for (; idx <= n; idx += idx & -idx)
            bit[idx] += val;
    }

    long long sum(int idx) {
        long long res = 0;
        for (; idx > 0; idx -= idx & -idx)
            res += bit[idx];
        return res;
    }

    long long range_sum(int l, int r) {
        return sum(r) - sum(l - 1);
    }

    int lower_bound(long long target) {
        int idx = 0;
        long long sum = 0;
        int bitMask = 1 << (31 - __builtin_clz(n));
        for (; bitMask; bitMask >>= 1) {
            int next = idx + bitMask;
            if (next <= n && sum + bit[next] < target) {
                idx = next;
                sum += bit[next];
            }
        }
        return idx + 1;
    }

    int upper_bound(long long target) {
        int idx = 0;
        long long sum = 0;
        int bitMask = 1 << (31 - __builtin_clz(n));
        for (; bitMask; bitMask >>= 1) {
            int next = idx + bitMask;
            if (next <= n && sum + bit[next] <= target) {
                idx = next;
                sum += bit[next];
            }
        }
        return idx + 1;
    }
};

// Example usage:
// Fenwick fw(n);
// fw.add(3, 5);
// fw.add(6, 2);
// cout << fw.sum(6) << "\n";
// cout << fw.range_sum(3,6) << "\n";
// cout << fw.lower_bound(6) << "\n";
// cout << fw.upper_bound(6) << "\n";
